module CVE_2022_21907;

redef enum Notice::Type += {
    CVE_2022_21907_EXPLOIT_ATTEMPT
    };

redef record HTTP::State += {
    CVE_2022_21907_spray_count: count &default = 0;
    CVE_2022_21907_notice_raised: bool &default = F;  
    };

global spray_min:count = 1750;
global spray_threshold:count = 20;
global malpattern: pattern = /(GET|HEAD|PATCH|POST|PUT) [^\x0a\x20]+\x0a/;

event http_message_done(c: connection, is_orig: bool, stat: http_message_stat)
    {
    if (!is_orig)
        return;
    # If we've already reached threshold, don't look any more.
    if (c$http_state$CVE_2022_21907_notice_raised || 
        c$http_state$CVE_2022_21907_spray_count > spray_threshold)
        return;
    if (stat$header_length > spray_min)
        ++c$http_state$CVE_2022_21907_spray_count;
    }

event Weird::log_weird(rec: Weird::Info)
    {
    if (!rec?$conn || !rec$conn?$http_state)
        return;
    if (rec$name != "HTTP_version_mismatch")
        return;
    if (rec$conn$http_state$CVE_2022_21907_notice_raised)
        return;
    if (rec$conn$http_state$CVE_2022_21907_spray_count > spray_threshold)
        {
        local current_packet = get_current_packet();
        if (current_packet?$data && malpattern in current_packet$data)
            {
            rec$conn$http_state$CVE_2022_21907_notice_raised = T;
            NOTICE([$note=CVE_2022_21907_EXPLOIT_ATTEMPT,
                    $conn=rec$conn,
                    $identifier=cat(rec$conn$id$orig_h,rec$conn$id$resp_h,rec$conn$id$resp_p),
                    # $suppress_for=3600sec,
                    $msg=fmt("Possible CVE_2022_21907 exploit over HTTP, multiple sprays followed by the triggering malformed request"),
                    $sub=fmt("get_current_packet data=%s",current_packet$data)]);
            }
        }
    }
