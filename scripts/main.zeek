module CVE_2022_21907;

redef enum Notice::Type += {
    CVE_2022_21907_EXPLOIT_ATTEMPT
    };
redef enum HTTP::Tags += {
    CVE_2022_21907
    };

const  trigger_sizes: set[count]  = {1974,  2150,  2766,  2362,  1746};
# TODO check this assumption re content, it may be not necessarily be a trigger.
const  trigger_content: pattern = /application\/signed-exchange/;
# TODO use orig_h/resp_h/resp_p tuple instead of just src
global ip_triggered_size: table[addr] of count &default=0 &write_expire=60sec;


# TODO CLUSTERIZE, although it may still work non clusterized because a lot of connections on 
# the same stream. Though same stream probably isn't a necessary condition to trigger
event http_header(c: connection, is_orig: bool, name: string, value: string)
    {
    if (!is_orig)
        return; 
    if (|value| in CVE_2022_21907::trigger_sizes)
        {
        ++CVE_2022_21907::ip_triggered_size[c$id$orig_h];
        # print(CVE_2022_21907::ip_triggered_size);
        }
    }

event http_message_done (c: connection, is_orig: bool, stat: http_message_stat)
    {
    if (c$id$orig_h !in ip_triggered_size)
        return;
    if (c$http?$uri && trigger_content in c$http$uri)
        {
        add c$http$tags[CVE_2022_21907];
        NOTICE([$note=CVE_2022_21907_EXPLOIT_ATTEMPT,
                $conn=c,
                $identifier=cat(c$id$orig_h,c$id$resp_h,c$id$resp_p),
                # TODO this is a noisy sploit, will need to supress
                $suppress_for=3600sec,
                # TODO words
                $msg=fmt("Possible CVE_2022_21907 exploit")]);
                # TODO add useful data to sub, eg sample of spray and client headers
        }
    }